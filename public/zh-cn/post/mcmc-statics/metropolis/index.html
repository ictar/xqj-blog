

<!DOCTYPE html>
<html lang="zh-cn" itemscope itemtype="http://schema.org/WebPage">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

 


      <title>Metropolis 算法详解：从原理到 Python 实现 - </title>

  <meta name="description" content="Metropolis 算法是如何解决归一化常数难题的？本文详细解析 Metropolis 采样背后的详细平衡原理，并通过 Python 代码演示随机游走在高维分布中的表现与调参技巧。">
  <meta name="author" content="Qiongjie.X"/>


<link rel="canonical" href="http://localhost:1313/zh-cn/post/mcmc-statics/metropolis/" />


<meta name="keywords" content="MCMC, Metropolis算法, 蒙特卡洛模拟, 贝叶斯统计, Python实现, 随机游走" /><script type="application/ld+json">
{
    "@context": "http://schema.org",
    "@type": "WebSite",
    "name": "琼呀",
    
    "url": "http:\/\/localhost:1313\/"
}
</script>

<script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
        "@type": "ListItem",
        "position": 1,
        "item": {
          "@id": "http:\/\/localhost:1313\/",
          "name": "home"
        }
    },{
        "@type": "ListItem",
        "position": 3,
        "item": {
          "@id": "http:\/\/localhost:1313\/zh-cn\/post\/mcmc-statics\/metropolis\/",
          "name": "Metropolis 算法详解：从原理到 python 实现"
        }
    }]
}
</script><script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "Article",
  "author": {
    "name" : "Qiongjie.X"
  },
  "headline": "Metropolis 算法详解：从原理到 Python 实现",
  "description" : "Metropolis 算法是如何解决归一化常数难题的？本文详细解析 Metropolis 采样背后的详细平衡原理，并通过 Python 代码演示随机游走在高维分布中的表现与调参技巧。",
  "inLanguage" : "zh-cn",
  "wordCount":  2875 ,
  "datePublished" : "2026-01-24T00:00:00\u002b00:00",
  "dateModified" : "2026-01-24T00:00:00\u002b00:00",
  "image" : "http:\/\/localhost:1313\/img\/avatar-icon.png",
  "keywords" : [ "MCMC, Metropolis算法, 蒙特卡洛模拟, 贝叶斯统计, Python实现, 随机游走" ],
  "mainEntityOfPage" : "http:\/\/localhost:1313\/zh-cn\/post\/mcmc-statics\/metropolis\/",
  "publisher" : {
    "@type": "Organization",
    "name" : "http:\/\/localhost:1313\/",
    "logo" : {
        "@type" : "ImageObject",
        "url" : "http:\/\/localhost:1313\/img\/avatar-icon.png",
        "height" :  60 ,
        "width" :  60
    }
  }
}
</script>



<meta property="og:title" content="Metropolis 算法详解：从原理到 Python 实现" />
<meta property="og:description" content="Metropolis 算法是如何解决归一化常数难题的？本文详细解析 Metropolis 采样背后的详细平衡原理，并通过 Python 代码演示随机游走在高维分布中的表现与调参技巧。">
<meta property="og:image" content="http://localhost:1313/img/avatar-icon.png" />
<meta property="og:url" content="http://localhost:1313/zh-cn/post/mcmc-statics/metropolis/" />
<meta property="og:type" content="website" />
<meta property="og:site_name" content="琼呀" />

  <meta name="twitter:title" content="Metropolis 算法详解：从原理到 Python 实现" />
  <meta name="twitter:description" content="Metropolis 算法是如何解决归一化常数难题的？本文详细解析 Metropolis 采样背后的详细平衡原理，并通过 Python 代码演示随机游走在高维分布中的表现与调参技巧。">
  <meta name="twitter:image" content="http://localhost:1313/img/avatar-icon.png" />
  <meta name="twitter:card" content="summary_large_image" />
  <link href='http://localhost:1313/favicon.ico' rel='icon' type='image/x-icon'/>
  <meta name="generator" content="Hugo 0.147.4">
  <link rel="alternate" href="http://localhost:1313/zh-cn/index.xml" type="application/rss+xml" title="琼呀"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.css" integrity="sha384-3UiQGuEI4TTMaFmGIZumfRPtfKQ3trwQE2JgosJxCnGmQpL/lJdjpcHkaaFwHlcI" crossorigin="anonymous">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.6.0/css/all.css" integrity="sha384-h/hnnw1Bi4nbpD6kE7nYfCXzovi622sY5WBxww8ARKwpdLj5kUWjRuyiXaD1U2JT" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/css/bootstrap.min.css" integrity="sha384-HSMxcRTRxnN+Bdg0JdbxYKrThecOKuH5zCYotlSAcp1+c8xmyTe9GYg1l9a69psu" crossorigin="anonymous"><link rel="stylesheet" href="http://localhost:1313/css/main.css" /><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" /><link rel="stylesheet" href="http://localhost:1313/css/syntax.css" /><link rel="stylesheet" href="http://localhost:1313/css/codeblock.css" /><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.css" integrity="sha384-h/L2W9KefUClHWaty3SLE5F/qvc4djlyR4qY3NUV5HGQBBW7stbcfff1+I/vmsHh" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/default-skin/default-skin.min.css" integrity="sha384-iD0dNku6PYSIQLyfTOpB06F2KCZJAKLOThS5HRe8b3ibhdEQ6eKsFf/EeFxdOt5R" crossorigin="anonymous">



<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  crossorigin="anonymous"
/>
<link rel="stylesheet" href="http://localhost:1313/css/custom.css"><link rel="stylesheet" href="http://localhost:1313/css/toc.css">

<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  crossorigin="anonymous"
></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
  onload="renderMathInElement(document.body, {
    delimiters: [
      {left: '$$', right: '$$', display: true},
      {left: '$', right: '$', display: false}
    ]
  });"></script>


<link rel="icon" type="image/png" href="http://localhost:1313/img/favicon-96x96.png" sizes="96x96" />
<link rel="icon" type="image/svg+xml" href="http://localhost:1313/img/favicon.svg" />
<link rel="apple-touch-icon" sizes="180x180" href="http://localhost:1313/img/apple-touch-icon.png" />
<link rel="manifest" href="http://localhost:1313/img/site.webmanifest" />

  </head>
  <body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
  <div class="container-fluid">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
        <span class="sr-only">切换导航</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="http://localhost:1313/zh-cn/">琼呀</a>
    </div>

    <div class="collapse navbar-collapse" id="main-navbar">
      <ul class="nav navbar-nav navbar-right">
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" role="button" tabindex="0" href="/zh-cn/post">文章</a>
              <div class="navlinks-children">
                
                  <a href="/zh-cn/post/python-geodata">用 Python 玩转遥感数据</a>
                
                  <a href="/zh-cn/post/mcmc-statics">蒙特卡洛-马尔可夫链统计方法</a>
                
                  <a href="/zh-cn/post/ai-fundamentals">AI 基础系列</a>
                
                  <a href="/zh-cn/post/geoai">GeoAI 系列</a>
                
              </div>
            </li>
          
        
          
            <li class="navlinks-container">
              <a class="navlinks-parent" role="button" tabindex="0" href="/zh-cn/projects">项目</a>
              <div class="navlinks-children">
                
                  <a href="https://ictar.github.io/TerraFlow/">TerraFlow</a>
                
              </div>
            </li>
          
        
          
            <li>
              <a title="笔记" href="/zh-cn/notes">笔记</a>
            </li>
          
        
          
            <li>
              <a title="标签" href="/zh-cn/tags">标签</a>
            </li>
          
        
          
            <li>
              <a title="关于我" href="/zh-cn/page/about/">关于我</a>
            </li>
          
        

        
          
            <li>
              
                
                  <a href="http://localhost:1313/post/mcmc-statics/metropolis/">EN</a>
                
              
            </li>
          
        

        
      </ul>
    </div>

    
      <div class="avatar-container">
        <div class="avatar-img-border">
          <a title="琼呀" href="http://localhost:1313/zh-cn/">
            <img class="avatar-img" src="http://localhost:1313/img/avatar-icon.png" alt="琼呀" />
           
          </a>
        </div>
      </div>
    

  </div>
</nav>




    


<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>


  
  
  






  

  <header class="header-section ">
    
    
    <div class="intro-header no-img">
      <div class="container">
        <div class="row">
          <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
            <div class="post-heading">
              
                <h1>Metropolis 算法详解：从原理到 Python 实现</h1>
              
              
              
              
                <span class="post-meta">
  
  
  <i class="fas fa-calendar"></i>&nbsp;发表于 January 24, 2026
  
  
  
    &nbsp;|&nbsp;<i class="fas fa-book"></i>&nbsp;2875&nbsp;个字
  
  
  &nbsp;&bull;&nbsp;其它语言: <a href="http://localhost:1313/post/mcmc-statics/metropolis/" lang="en">EN</a>
</span>


              
            </div>
          </div>
        </div>
      </div>
    </div>
  
  </header>


    
<div class="container" role="main">
  <div class="row" style="display: flex; flex-wrap: wrap;">
    
    
    <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1">
      <article role="main" class="blog-post">
        
  <aside class="toc">
    <h2>目录</h2>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#我们要解决什么问题the-core-problem">我们要解决什么问题？(The Core Problem)</a>
      <ul>
        <li><a href="#1-核心困境无法计算的">1. 核心困境：无法计算的 </a>
          <ul>
            <li><a href="#关于">关于 </a></li>
          </ul>
        </li>
        <li><a href="#2-metropolis-的解决策略相对比值法">2. Metropolis 的解决策略：相对比值法</a></li>
        <li><a href="#3-连接点为什么要用马尔可夫链">3. 连接点：为什么要用马尔可夫链？</a></li>
      </ul>
    </li>
    <li><a href="#metropolis随机游走">Metropolis（随机游走）</a>
      <ul>
        <li><a href="#三个版本的接受率">三个版本的接受率 </a>
          <ul>
            <li><a href="#版本一metropolis-选择-the-metropolis-choice">版本一：Metropolis 选择 (The Metropolis Choice)</a></li>
            <li><a href="#版本-二barker-选择-the-barker-choice--glauber-dynamics">版本 二：Barker 选择 (The Barker Choice / Glauber Dynamics)</a></li>
            <li><a href="#版本三metropolis-hastings-mh-接受率">版本三：Metropolis-Hastings (MH) 接受率</a></li>
          </ul>
        </li>
        <li><a href="#算法流程">算法流程</a>
          <ul>
            <li><a href="#离散-metropolis-算法">离散 Metropolis 算法</a></li>
            <li><a href="#连续-metropolis-算法">连续 Metropolis 算法</a></li>
          </ul>
        </li>
        <li><a href="#的选择"> 的选择</a>
          <ul>
            <li><a href="#尺度-scale步子该迈多大">尺度 (Scale)：步子该迈多大？</a></li>
            <li><a href="#形状-shape尾巴该有多长">形状 (Shape)：尾巴该有多长？</a></li>
            <li><a href="#方向-orientation如何穿越峡谷">方向 (Orientation)：如何穿越峡谷？</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#收敛-convergence-和-混合-mixing">收敛 (Convergence) 和 混合 (Mixing)</a>
      <ul>
        <li><a href="#什么是-mixing-混合">什么是 Mixing (混合)？</a></li>
        <li><a href="#核心度量工具自相关函数-acf">核心度量工具：自相关函数 (ACF)</a>
          <ul>
            <li><a href="#场景-a-the-smooth-chain-平滑链--步长太小">场景 A: The Smooth Chain (平滑链 / 步长太小)</a></li>
            <li><a href="#场景-b-the-stiff-chain-僵硬链--步长太大">场景 B: The Stiff Chain (僵硬链 / 步长太大)</a></li>
            <li><a href="#黄金平衡有效样本量-ess">黄金平衡：有效样本量 (ESS)</a></li>
            <li><a href="#相关性的-u-型曲线">相关性的 U 型曲线</a></li>
            <li><a href="#示例三张-acf-图">示例：三张 ACF 图</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#burn-in预热--老化">Burn-in（预热 / 老化）</a>
      <ul>
        <li><a href="#为什么要扔掉它们the-bias-problem">为什么要扔掉它们？(The Bias Problem)</a></li>
        <li><a href="#python-视觉实战看见-burn-in">Python 视觉实战：看见 Burn-in</a></li>
        <li><a href="#burn-in-要设多长">Burn-in 要设多长？</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </aside>

<h1 id="我们要解决什么问题the-core-problem">我们要解决什么问题？(The Core Problem)</h1>
<h2 id="1-核心困境无法计算的">1. 核心困境：无法计算的 $Z$</h2>
<p>在贝叶斯统计、物理模拟和高维计算中，我们经常需要从一个复杂的概率分布 $\pi(x)$ 中进行采样。但是，我们通常只知道这个分布的“形状”，却不知道它的“规模”。</p>
<ul>
<li><strong>已知</strong>： 未归一化的密度函数 $f(x)$（相对权重）。</li>
<li><strong>未知</strong>： 归一化常数 $Z$（总和或积分）。$$\pi(x) = \frac{f(x)}{Z}, \quad \text{其中 } Z = \int f(x) dx$$</li>
<li><strong>痛点</strong>： 在高维空间中，计算 $Z$（遍历整个空间求和）是计算上不可行的 (Intractable)。</li>
<li><strong>后果</strong>： 因为不知道 $Z$，我们无法算出绝对概率 $\pi(x)$，传统的直接采样方法（如逆变换法）全部失效。</li>
</ul>
<h3 id="关于">关于 $\pi$</h3>
<table>
  <thead>
      <tr>
          <th>场景</th>
          <th>$\pi$ 的形式</th>
          <th>数学名称</th>
          <th>物理意义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>基础马尔可夫链</strong></td>
          <td>向量</td>
          <td>平稳分布向量</td>
          <td>各个状态的长期停留概率</td>
      </tr>
      <tr>
          <td><strong>Metropolis (MCMC)</strong></td>
          <td>函数</td>
          <td>目标概率密度</td>
          <td>我们希望采集样本的那个“形状”</td>
      </tr>
  </tbody>
</table>
<h2 id="2-metropolis-的解决策略相对比值法">2. Metropolis 的解决策略：相对比值法</h2>
<p>Metropolis 算法的核心洞见是：<strong>既然 $Z$ 算不出来，那就消掉它。</strong></p>
<p>如果不去计算绝对概率，而是比较两个状态之间的<strong>相对概率比值</strong>，常数 $Z$ 就会在分子分母中自动抵消：
</p>
$$\frac{\pi(x_{\text{new}})}{\pi(x_{\text{old}})} = \frac{f(x_{\text{new}}) / Z}{f(x_{\text{old}}) / Z} = \frac{f(x_{\text{new}})}{f(x_{\text{old}})}$$<p>这使得我们只利用<strong>相对高低</strong>（$f(x)$的比值）就能判断两个状态的优劣，从而绕过了计算 $Z$ 的难题。</p>
<h2 id="3-连接点为什么要用马尔可夫链">3. 连接点：为什么要用马尔可夫链？</h2>
<p>既然我们只能做“局部比较”（比较当前位置和下一步位置），我们就无法一步到位地生成独立样本。我们需要一个能够<strong>在空间中游走</strong>的机制，这就引入了马尔可夫链。</p>
<ul>
<li>
<p><strong>动态模拟静态：</strong> 我们的目标是得到一个<strong>静态分布</strong>  $\pi$ 的样本，Metropolis 的手段是构造一个<strong>动态过程</strong>（马尔可夫链）。</p>
</li>
<li>
<p><strong>逆向工程思维：</strong></p>
<ul>
<li><strong>传统马尔可夫链问题：</strong> 给定转移矩阵  $P$ ，求稳态分布  $\pi$ 。</li>
<li><strong>Metropolis (MCMC) 问题：</strong> 已知目标分布 $\pi$ ，<strong>设计</strong>一个转移矩阵 $P$，使得这个链最终收敛到  $\pi$。</li>
</ul>
</li>
<li>
<p><strong>算法本质：</strong>
Metropolis 算法通过<strong>细致平衡原则 (Detailed Balance)</strong> 构造了特殊的“接受/拒绝”规则，实时生成了一个<strong>HIA 链</strong>（齐次、不可约、非周期）。</p>
</li>
<li>
<p><strong>最终结论：</strong>
根据<strong>遍历定理 (Ergodic Theorem)</strong>，这个马尔可夫链跑出来的<strong>轨迹 (Trajectory)</strong>，在长期统计上等价于从目标分布  $Z$ 中抽取的样本。</p>
</li>
</ul>
<blockquote>
<p><strong>一句话总结：</strong>
Metropolis 算法是为了解决 <strong>“在归一化常数 $Z$ 未知的情况下进行采样”</strong> 的难题，它通过 <strong>“构造一个以目标分布为稳态的马尔可夫链”</strong> 来实现这一目标。</p></blockquote>
<h1 id="metropolis随机游走">Metropolis（随机游走）</h1>
<p>为了保证收敛到 $\pi$，我们只需要构造一个满足 细致平衡方程 的链：
</p>
$$\pi_i P_{ij} = \pi_j P_{ji}$$<p>Metropolis 算法把转移过程拆成了两步：</p>
<ol>
<li><strong>提议 (Proposal)</strong> $Q_{ij}$：提议转移方程。在数学符号里，它通常写作 $Q(x_{new} | x_{old})$ 或者 $q(x' | x)$。意思是：“已知我现在站在 $x_{old}$，我下一步提议跳到 $x_{new}$ 的概率是多少？”
<ul>
<li>请注意，它叫“提议” (Proposal)。因为它只是负责建议：“嘿，我们要不要试试去那里？” 至于到底去不去，那是后面 $\alpha$ (接受率) 决定的事。</li>
<li>在原始的 Metropolis 算法中，$Q$ 必须是<strong>对称的（Symmetry）</strong>：$$Q(x_{new} | x_{old}) = Q(x_{old} | x_{new})$$
<ul>
<li>这样在后续计算接受率的时候，我们就可以把 $Q$ 消去了。</li>
</ul>
</li>
<li>在实践时，$Q$ 通常就是一行简单的随机数生成代码。它有两种常见的形态
<ul>
<li>A. 均匀游走 (Uniform Random Walk)
<ul>
<li>代码：  <code>x_new = x_old + random.uniform(-1, 1)</code></li>
<li>逻辑： 以当前位置为中心，画一个宽为 2 的盒子，盒子里的任何一个点被选中的概率都一样。</li>
<li>特点： 简单粗暴。</li>
</ul>
</li>
<li>B. 高斯游走 (Gaussian Random Walk)
<ul>
<li>代码：  <code>x_new = x_old + random.normal(0, sigma)</code></li>
<li>逻辑： 以当前位置为中心，生成一个正态分布。离当前位置越近的点，越容易被提议；太远的点很少被提议。</li>
<li>特点： 更符合自然界的移动规律（大多数时候迈小步，偶尔迈大步）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>接受 (Acceptance)</strong> $\alpha_{ij}$： 决定“我真的要跳过去吗，还是留在原地？”。
<ul>
<li>接受率虽然是由状态对 $(i, j)$ 决定的固定值，但在工程上，因为状态数量 $N$ 是天文数字，我们永远无法把这个 $N \times N$ 的表格预先算出来存储。我们只能 <strong>“走到哪，算到哪”</strong>。</li>
<li>⚠️ Metropolis 算法存在的全部意义，就是因为状态空间太大（或连续无限），导致我们无法提前确定这个关于接受率的“二维数组”。</li>
</ul>
</li>
</ol>
<p>所以，实际的转移概率是：$P_{ij} = Q_{ij} \times \alpha_{ij}$（注意这里 $i \ne j$）。把它代入细致平衡方程：
</p>
$$\pi_i (Q_{ij} \alpha_{ij}) = \pi_j (Q_{ji} \alpha_{ji})$$<p>假设我们使用的是<strong>对称的提议规则</strong>（即 $Q_{ij} = Q_{ji}$，比如向左跳和向右跳的概率一样，都是 0.5）。那么方程就简化为：
</p>
$$\pi_i \alpha_{ij} = \pi_j \alpha_{ji}$$<p>
或者写成比率：
</p>
$$\frac{\alpha_{ij}}{\alpha_{ji}} = \frac{\pi_j}{\pi_i}$$<h2 id="三个版本的接受率">三个版本的接受率 $\alpha_{ij}$</h2>
<table>
  <thead>
      <tr>
          <th style="text-align: left">版本</th>
          <th style="text-align: left">公式核心</th>
          <th style="text-align: left">适用性</th>
          <th style="text-align: left">效率 (Peskun序)</th>
          <th style="text-align: left">备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">1. Metropolis</td>
          <td style="text-align: left">$\frac{\pi_j}{\pi_i}$</td>
          <td style="text-align: left">仅对称 $q$</td>
          <td style="text-align: left">⭐⭐⭐ (最高)</td>
          <td style="text-align: left">简单粗暴，只要能用就用它。</td>
      </tr>
      <tr>
          <td style="text-align: left">2. Barker</td>
          <td style="text-align: left">$\frac{\pi_j}{\pi_i + \pi_j}$</td>
          <td style="text-align: left">仅对称 $q$</td>
          <td style="text-align: left">⭐ (较低)</td>
          <td style="text-align: left">物理学偏爱，数学性质好（光滑），但拒绝率高。</td>
      </tr>
      <tr>
          <td style="text-align: left">3. MH</td>
          <td style="text-align: left">$\frac{\pi_j q_{ji}}{\pi_i q_{ij}}$</td>
          <td style="text-align: left">任意 $q$</td>
          <td style="text-align: left">⭐⭐⭐ (最高)</td>
          <td style="text-align: left">现代 MCMC 的基石，涵盖了第 1 种情况。</td>
      </tr>
  </tbody>
</table>
<h3 id="版本一metropolis-选择-the-metropolis-choice">版本一：Metropolis 选择 (The Metropolis Choice)</h3>
<p>假设你现在处于状态 $i$，系统建议你跳到状态 $j$。如果状态 $j$ 的概率比状态 $i$ 更高（即 $\pi_j > \pi_i$，这一步是往“高处”走），为了满足上面的比率，接受概率 $\alpha_{ij}$ 应该设为 1 (100%) 最合适（也最有效率）。因为既然 $\pi_j > \pi_i$，说明新状态 $j$ 是一个“更好”或者是“更重要”的状态，我们总是乐意往高处走，所以我们毫不犹豫地接受这个提议。</p>
<p>这得到了著名的 Metropolis 接受准则 (Acceptance Probability)：
</p>
$$\alpha_{ij} = \min \left( 1, \frac{\pi_j}{\pi_i} \right)$$<p>
它包含了两种情况：</p>
<ol>
<li>往高处走 ($\pi_j > \pi_i$)： 比值 $>1$，取 $\min$ 后得到 1。总是接受。</li>
<li>往低处走 ($\pi_j < \pi_i$)： 比值 $<1$，取 $\min$ 后得到 $\frac{\pi_j}{\pi_i}$。
<ul>
<li>这才是算法的灵魂！</li>
<li>即使新状态不如现在好，我们也有一定的概率（虽然不是 100%）接受它。</li>
<li><strong>为什么？</strong> 为了防止陷入“局部最优” (Local Optima)。偶尔接受坏结果，能让你跳出小坑，去寻找更远处的最高峰。</li>
</ul>
</li>
</ol>
<p>🔍 适用条件：提议分布必须是对称的，即 $q_{ij} = q_{ji}$（从 $i$ 跳到 $j$ 的概率等于从 $j$ 跳回 $i$ 的概率）。</p>
<ul>
<li>例子： 随机游走，向左一步和向右一步概率相等。</li>
</ul>
<h4 id="证明">证明</h4>
$$
\pi_ip_{ij} = \pi_iq_{ij}\alpha_{ij} = \pi_iq_{ij}\min \left( 1, \frac{\pi_j}{\pi_i} \right) = q_{ij}\min \left( \pi_i, \pi_j \right) = q_{ij}\min \left( \pi_j, \pi_i \right) = \pi_jq_{ij}\min \left( 1, \frac{\pi_i}{\pi_j} \right) = \pi_jq_{ji}\min \left( 1, \frac{\pi_i}{\pi_j} \right) = \pi_jq_{ji} \alpha_{ji}
$$<h4 id="优劣">优劣</h4>
<ul>
<li>✅ 优势（<strong>Peskun 定理</strong>）： 这是数学上<strong>最优</strong>的选择。Peskun (1973) 证明了，在所有满足细致平衡的接受率函数中，Metropolis 选择能使得估计量的渐近方差最小。简单说：它最不爱拒绝人，能在保持平衡的前提下最大化流动性。</li>
<li>❌ 劣势：
<ul>
<li>受限。必须保证提议分布对称，无法处理非对称的复杂提议（如 Log-Normal）。</li>
<li>从计算机计算的角度来说，“对比操作”效率更低。</li>
</ul>
</li>
</ul>
<h3 id="版本-二barker-选择-the-barker-choice--glauber-dynamics">版本 二：Barker 选择 (The Barker Choice / Glauber Dynamics)</h3>
<p>这个版本由 Barker (1965) 提出，在统计物理中（特别是 Ising 模型和自旋玻璃模拟）被称为 Glauber Dynamics 或 Heat Bath 的变体。</p>
$$
\alpha_{ij} = \frac{\pi_i}{\pi_i+\pi_j}
$$<p>🔍 适用条件：同样通常用于 <strong>对称提议</strong>($q_{ij}=q_{ji}$) 的场景。常见于统计物理中的 Ising 模型 模拟（也称为 Heat Bath 算法的一种形式）。</p>
<h4 id="证明-1">证明</h4>
<p>同样假设对称 $q$，只需证明 $\pi_i \alpha_{ij} = \pi_j \alpha_{ji}$。</p>
<ul>
<li>左边 ($i \to j$)：$$\pi_i \times \frac{\pi_j}{\pi_i + \pi_j} = \frac{\pi_i \pi_j}{\pi_i + \pi_j}$$</li>
<li>右边 ($j \to i$)：$$\pi_j \times \frac{\pi_i}{\pi_j + \pi_i} = \frac{\pi_j \pi_i}{\pi_i + \pi_j}$$</li>
<li>结论： 分子分母完全一样。得证。</li>
</ul>
<h4 id="优劣-1">优劣</h4>
<ul>
<li>✅ 优势：<strong>函数光滑</strong>。$\min(1, x)$ 函数在 1 处有一个尖角（不可导），而 $\frac{x}{1+x}$ 是一条平滑的 Sigmoid 曲线。在某些需要对动力学过程求导的理论分析中，这个性质非常重要。</li>
<li>❌ 劣势： 效率较低。
<ul>
<li>当 $\pi_j > \pi_i$ 时，Metropolis 会 100% 接受。</li>
<li>但 Barker 即使面对更好的状态，接受率也永远小于 1（例如 $\pi_j = \pi_i$ 时，Metropolis 接受率是 1，Barker 只有 0.5）。这意味着它会拒绝更多的好样本，收敛变慢。</li>
</ul>
</li>
</ul>
<h3 id="版本三metropolis-hastings-mh-接受率">版本三：Metropolis-Hastings (MH) 接受率</h3>
$$
\alpha_{ij} = \min \left(1, \frac{q_{ji}\pi_j}{q_{ij}\pi_i}\right)
$$<p>🔍 适用条件:通用完全体。适用于<strong>任何提议分布</strong> $q$，无论是否对称。它是第 1 种情况（版本一）的一般化形式。</p>
<h4 id="数学证明">数学证明</h4>
<p>我们要证明完整形式：$\pi_i q_{ij} \alpha_{ij} = \pi_j q_{ji} \alpha_{ji}$。</p>
<p>定义接受率比值 $R = \frac{\pi_j q_{ji}}{\pi_i q_{ij}}$。不妨设 $R \ge 1$（即 $i \to j$ 是更有利或更倾向的流动方向）：</p>
<ul>
<li>左边 ($i \to j$)： $\alpha_{ij} = \min(1, R) = 1$。$$\text{Left} = \pi_i q_{ij}$$</li>
<li>右边 ($j \to i$)： 逆向的比值是 $1/R$，因为 $R \ge 1 \implies 1/R \le 1$，所以 $\alpha_{ji} = 1/R = \frac{\pi_i q_{ij}}{\pi_j q_{ji}}$。$$\text{Right} = \pi_j q_{ji} \times \left( \frac{\pi_i q_{ij}}{\pi_j q_{ji}} \right)$$消去 $\pi_j q_{ji}$ 后：$$\text{Right} = \pi_i q_{ij}$$</li>
<li>结论： 左边 = 右边。得证。</li>
</ul>
<h4 id="优劣-2">优劣</h4>
<ul>
<li>✅ 优势：<strong>极其灵活</strong>。因为引入了 $q_{ji}/q_{ij}$ 这个Hastings 修正项，你可以设计任何你喜欢的提议分布（比如 Log-Normal, MALA, 甚至神经网络生成的分布），只要能计算出概率密度即可。它解决了边界问题和高维引导问题。</li>
<li>❌ 劣势： 计算略繁琐。每次迭代都需要计算 $q$ 的比值。如果 $q$ 函数很复杂，计算成本会增加。</li>
</ul>
<h2 id="算法流程">算法流程</h2>
<h3 id="离散-metropolis-算法">离散 Metropolis 算法</h3>
<ol>
<li>定义与假设
<ul>
<li><strong>状态空间 (State Space)</strong>：$S = \{s_1, s_2, \dots, s_n\}$，是一个有限离散集合。</li>
<li>目标分布 (Target Distribution)：$\pi = (\pi_1, \pi_2, \dots, \pi_n)$，满足 $\sum \pi_i = 1$。
<ul>
<li>这是一个极限稳定的分布。</li>
</ul>
</li>
<li>提议矩阵 (Proposal Matrix)：$Q = (q_{ij})$，其中 $q_{ij} = P(X^* = s_j | X_t = s_i)$。
<ul>
<li>对称性要求：$q_{ij} = q_{ji}, \forall i, j$。</li>
</ul>
</li>
<li>当前状态：设 $X_t = s_i$。</li>
</ul>
</li>
<li>转移算法步骤：在每一时刻 $t$，转移到 $t+1$ 的过程如下：
<ol>
<li><strong>提议阶段 (Proposal Phase)</strong>：
<ol>
<li>生成随机变量 $U_1 \sim \text{Uniform}(0, 1)$。</li>
<li>根据 $Q$ 矩阵的第 $i$ 行离散分布确定候选状态 $s_j$。具体地，找到 $j$ 使得：$$\sum_{k=1}^{j-1} q_{ik} \le U_1 < \sum_{k=1}^{j} q_{ik}$$</li>
</ol>
</li>
<li><strong>接受阶段 (Acceptance Phase)</strong>：
<ol>
<li>计算接受概率 $\alpha_{ij} = \min \left( 1, \frac{\pi_j}{\pi_i} \right)$。</li>
<li>生成随机变量 $U_2 \sim \text{Uniform}(0, 1)$。</li>
<li>更新状态：$$X_{t+1} = \begin{cases} s_j & \text{若 } U_2 \le \alpha_{ij} \quad (\text{接受}) \\ s_i & \text{若 } U_2 > \alpha_{ij} \quad (\text{拒绝}) \end{cases}$$
<ul>
<li>注意，当 $\pi_j \lt \pi_i$ 时，$\alpha_{ij}=1$，这个时候总是接受的。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h4 id="示例">示例</h4>
<p><strong>设定场景</strong></p>
<ul>
<li>状态空间：$S = \{1, 2, 3\}$。</li>
<li>目标分布：$\pi = (0.2, 0.5, 0.3)$。</li>
<li>提议矩阵 $Q$（设定为一个对称的转移矩阵，每个状态有相等的概率跳向任意状态，包括自身）：$$Q = \begin{pmatrix} 1/3 & 1/3 & 1/3 \\ 1/3 & 1/3 & 1/3 \\ 1/3 & 1/3 & 1/3 \end{pmatrix}$$</li>
</ul>
<p><strong>单步转移手算过程：</strong></p>
<p>假设当前状态 $X_t = 1$。</p>
<ol>
<li>第一步：生成提议状态
<ul>
<li>生成随机数 $U_1 = 0.72$。</li>
<li>查看 $Q$ 的第 1 行累积分布：$[0, 1/3, 2/3, 1]$。</li>
<li>由于 $2/3 \le 0.72 < 1$，落在第三个区间。</li>
<li>候选状态确定：$s_j = 3$。</li>
</ul>
</li>
<li>第二步：计算接受率
<ul>
<li>我们要从状态 1 跳往状态 3。</li>
<li>$\alpha_{13} = \min \left( 1, \frac{\pi_3}{\pi_1} \right) = \min \left( 1, \frac{0.3}{0.2} \right) = 1$。</li>
</ul>
</li>
<li>第三步：决定最终状态
<ul>
<li>生成随机数 $U_2 = 0.45$。</li>
<li>由于 $U_2 \le \alpha_{13}$ (即 $0.45 \le 1$)，<strong>接受提议</strong>。
<ul>
<li>⚠️ 事实上，这里因为 $\alpha_{13} == 1$，所以我们总是接受。</li>
</ul>
</li>
<li>结果：$X_{t+1} = 3$。</li>
</ul>
</li>
</ol>
<p>再走一步：假设当前 $X_{t+1} = 3$</p>
<ol>
<li>第一步：生成提议状态
<ul>
<li>生成随机数 $U_1 = 0.15$。查</li>
<li>看 $Q$ 的第 3 行累积分布：$[0, 1/3, 2/3, 1]$。</li>
<li>由于 $0 \le 0.15 < 1/3$，落在第一个区间。</li>
<li>候选状态确定：$s_j = 1$。</li>
</ul>
</li>
<li>第二步：计算接受率
<ul>
<li>我们要从状态 3 跳往状态 1。</li>
<li>$\alpha_{31} = \min \left( 1, \frac{\pi_1}{\pi_3} \right) = \min \left( 1, \frac{0.2}{0.3} \right) = 0.6667$。</li>
</ul>
</li>
<li>第三步：决定最终状态
<ul>
<li>生成随机数 $U_2 = 0.82$。</li>
<li>由于 $U_2 > \alpha_{31}$ (即 $0.82 > 0.6667$)，<strong>拒绝提议</strong>。</li>
<li>结果：$X_{t+2} = X_{t+1} = 3$。</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 1. 参数设置 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 目标分布 pi (岛A: 0.2, 岛B: 0.5, 岛C: 0.3)</span>
</span></span><span style="display:flex;"><span>pi <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0.2</span>, <span style="color:#ae81ff">0.5</span>, <span style="color:#ae81ff">0.3</span>])
</span></span><span style="display:flex;"><span>states_map <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>: <span style="color:#e6db74">&#39;Island A (0.2)&#39;</span>, <span style="color:#ae81ff">1</span>: <span style="color:#e6db74">&#39;Island B (0.5)&#39;</span>, <span style="color:#ae81ff">2</span>: <span style="color:#e6db74">&#39;Island C (0.3)&#39;</span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 提议矩阵 Q (对称，均匀跳跃)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Q[i][j] 代表从 i 提议去 j 的概率</span>
</span></span><span style="display:flex;"><span>Q <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([
</span></span><span style="display:flex;"><span>    [<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>],
</span></span><span style="display:flex;"><span>    [<span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span><span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">discrete_metropolis</span>(n_iter, initial_state):
</span></span><span style="display:flex;"><span>    samples <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    current_state <span style="color:#f92672">=</span> initial_state
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 预计算 Q 的累积分布，用于 U1 的分位数查找</span>
</span></span><span style="display:flex;"><span>    Q_cumsum <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>cumsum(Q, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t <span style="color:#f92672">in</span> range(n_iter):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># --- 第一步：生成提议 (U1) ---</span>
</span></span><span style="display:flex;"><span>        u1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 根据 Q 的当前行累积概率确定候选状态 j</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 对应数学公式：sum(q_ik) &lt; u1 &lt;= sum(q_ik)</span>
</span></span><span style="display:flex;"><span>        proposed_state <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>searchsorted(Q_cumsum[current_state], u1) <span style="color:#75715e"># 逆变换采样 (Inverse Transform Sampling) 的离散实现</span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># --- 第二步：计算接受率 alpha ---</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 这里的 pi_j / pi_i</span>
</span></span><span style="display:flex;"><span>        alpha <span style="color:#f92672">=</span> min(<span style="color:#ae81ff">1</span>, pi[proposed_state] <span style="color:#f92672">/</span> pi[current_state])
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># --- 第三步：判定是否转移 (U2) ---</span>
</span></span><span style="display:flex;"><span>        u2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> u2 <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 接受提议</span>
</span></span><span style="display:flex;"><span>            current_state <span style="color:#f92672">=</span> proposed_state
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># 拒绝提议，状态保持不变</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">pass</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        samples<span style="color:#f92672">.</span>append(current_state)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array(samples)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 2. 运行模拟 ---</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">5000</span>  <span style="color:#75715e"># 迭代次数</span>
</span></span><span style="display:flex;"><span>samples <span style="color:#f92672">=</span> discrete_metropolis(N, initial_state<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 3. 可视化展示 ---</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 图 1: 轨迹图 (Trace Plot) - 只看前 100 步</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这让我们看到具体的“跳跃”动作</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>step(range(<span style="color:#ae81ff">100</span>), samples[:<span style="color:#ae81ff">100</span>], where<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;mid&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, linewidth<span style="color:#f92672">=</span><span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>yticks([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [states_map[<span style="color:#ae81ff">0</span>], states_map[<span style="color:#ae81ff">1</span>], states_map[<span style="color:#ae81ff">2</span>]])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;1. Trace Plot (First 100 Steps)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Watch the jumper move!&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>, axis<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;y&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Step&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 图 2: 收敛图 (Convergence of Frequencies)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 展示频率是如何随时间逼近真实概率的</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 计算动态频率</span>
</span></span><span style="display:flex;"><span>iterations <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">1</span>, N <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>prob_0 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>cumsum(samples <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">/</span> iterations
</span></span><span style="display:flex;"><span>prob_1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>cumsum(samples <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> iterations
</span></span><span style="display:flex;"><span>prob_2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>cumsum(samples <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">/</span> iterations
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(prob_0, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Simulated A&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(prob_1, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Simulated B&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(prob_2, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Simulated C&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.6</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 画出理论横线</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(pi[<span style="color:#ae81ff">0</span>], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;True A (0.2)&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(pi[<span style="color:#ae81ff">1</span>], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;True B (0.5)&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(pi[<span style="color:#ae81ff">2</span>], color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;True C (0.3)&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;2. Convergence Plot</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Law of Large Numbers in action&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Iterations&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Estimated Probability&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 图 3: 最终直方图 vs 理论分布</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>counts <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>bincount(samples, minlength<span style="color:#f92672">=</span><span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>freqs <span style="color:#f92672">=</span> counts <span style="color:#f92672">/</span> N
</span></span><span style="display:flex;"><span>x_pos <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 画柱状图</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>bar(x_pos, freqs, width<span style="color:#f92672">=</span><span style="color:#ae81ff">0.4</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Simulation&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;gray&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 画理论点</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(x_pos, pi, <span style="color:#e6db74">&#39;ro&#39;</span>, markersize<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Theoretical Target&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;None&#39;</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 添加标签</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> i, v <span style="color:#f92672">in</span> enumerate(freqs):
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>text(i, v <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.01</span>, <span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>v<span style="color:#e6db74">:</span><span style="color:#e6db74">.3f</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>, ha<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;center&#39;</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bold&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xticks(x_pos, [states_map[<span style="color:#ae81ff">0</span>], states_map[<span style="color:#ae81ff">1</span>], states_map[<span style="color:#ae81ff">2</span>]])
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylim(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0.6</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;3. Final Distribution (N=</span><span style="color:#e6db74">{</span>N<span style="color:#e6db74">}</span><span style="color:#e6db74">)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Did we match the target?&#34;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="/img/contents/post/mcmc-statics/6_metropolis/6_mcmc_metropolis_5_0.png" alt="png"></p>
<ol>
<li>左上图：跳跃的细节 (Trace Plot)
<ul>
<li>这张图展示了算法的前 100 步。</li>
<li>直线部分： 你会看到有时候线条会在某一个水平高度（比如 Island B）保持好几步，形成一条横线。</li>
<li>数学含义： 这就是 <strong>拒绝 (Rejection)</strong>！
<ul>
<li>当小人在 B 岛，提议去 A 岛（$0.2/0.5$ 只有 40% 概率接受）。</li>
<li>随机数 $U_2 > 0.4$，拒绝！小人留在 B。</li>
<li>关键点： 虽然位置没变，但在数学上，这算作“我们在 B 又采样了一次”。这正是为什么 B 的概率会比 A 高的原因——因为易进难出。</li>
</ul>
</li>
</ul>
</li>
<li>右上图：大数定律的魔法 (Convergence)
<ul>
<li>这张图展示了随着步数 $N$ 增加，每个岛的统计频率是如何变化的。</li>
<li>初期 (0-500步)： 线条波动很大，很不稳定。</li>
<li>后期 (2000步以后)： 线条逐渐变平，死死地贴在虚线（理论值）上。</li>
<li>数学含义： 这就是 <strong>遍历性 (Ergodicity)</strong>。只要时间足够长，访问频率一定收敛于 $\pi$。</li>
</ul>
</li>
<li>下图：最终成绩单 (Comparison)
<ul>
<li>灰色的柱子是模拟出来的结果。</li>
<li>红色的圆点是定义的目标分布 $\pi$ 。</li>
<li>结果： 应该几乎完全重合。</li>
</ul>
</li>
</ol>
<h3 id="连续-metropolis-算法">连续 Metropolis 算法</h3>
<p><strong>定义与假设</strong></p>
<ul>
<li>$q(x, y)$ 或者 $K(x, y)$ (提议核): 这是一个函数。
<ul>
<li>含义：给定当前位置 $x$，提议跳到 $y$ 的概率密度。它对标离散离散场景下的 $Q$，因为在连续空间中，状态是无限的，我们没法用矩阵来表示。</li>
<li>最著名的例子是 <strong>高斯核 (Gaussian Kernel)</strong>：$$q(y|x) = \frac{1}{\sqrt{2\pi\sigma^2}} \exp\left( -\frac{(y-x)^2}{2\sigma^2} \right)$$</li>
<li>直观理解： 这就像以 $x$ 为中心的一个“钟形土包”。离 $x$ 越近的地方，被选为 $y$ 的概率越高。这其实就是我们之前说的 np.random.normal(x, sigma) 的数学本质。</li>
</ul>
</li>
<li>$\pi(x)$ (目标): 目标分布的概率密度函数 (PDF)。</li>
</ul>
<p><strong>算法步骤 (Algorithm Steps):</strong> 在时刻 $t$，当前状态为 $X_t = x$：</p>
<ol>
<li>提议阶段 (Proposal):
<ul>
<li>从提议核 $q(\cdot | x)$ 中生成一个候选点 $x^*$。</li>
<li>代码实现： <code>x_star = x + np.random.normal(0, sigma)</code> (如果用高斯核)。</li>
</ul>
</li>
<li>接受阶段 (Acceptance):
<ul>
<li>计算接受率 (这里假设对称核 $q(x,y)=q(y,x)$，如高斯核)：$$\alpha(x, x^*) = \min\left(1, \frac{\pi(x^*)}{\pi(x)}\right)$$</li>
<li>生成 $U \sim \text{Uniform}(0, 1)$。</li>
</ul>
</li>
<li>决策阶段 (Update):
$$
X_{t+1} = \begin{cases}
x^* & \text{若 } U \le \alpha(x, x^*) \\
x & \text{若 } U \> \alpha(x, x^*)
\end{cases}
$$</li>
</ol>
<h4 id="示例-1">示例</h4>
<p>地形描述：有两座山峰。</p>
<ul>
<li>主峰在 $x=2$。</li>
<li>次峰在 $x=-2$。</li>
<li>中间隔着深谷。</li>
</ul>
<p>挑战：如果我们用的 Proposal Kernel (高斯核) 的方差 $\sigma$ 太小（步子太小），小人可能会被困在其中一座山头，跳不过峡谷（局部最优陷阱）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 1. 定义目标分布 (双峰) ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这是一个非归一化的密度函数 (Unnormalized PDF)</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 峰 1: Mean=-2, Std=0.5</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 峰 2: Mean= 2, Std=0.5</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">target_pdf</span>(x):
</span></span><span style="display:flex;"><span>    p1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>exp(<span style="color:#f92672">-</span> (x <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>    p2 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>exp(<span style="color:#f92672">-</span> (x <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">/</span> (<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0.5</span><span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p1 <span style="color:#f92672">+</span> p2  <span style="color:#75715e"># 双峰叠加</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 2. 定义提议核 (Proposal Kernel) ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 这里使用对称的高斯核: q(y|x) ~ N(x, sigma^2)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sample_proposal_kernel</span>(current_x, sigma):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(current_x, sigma)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 3. 连续 Metropolis 算法 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">continuous_metropolis</span>(n_iter, start_x, sigma):
</span></span><span style="display:flex;"><span>    samples <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    current_x <span style="color:#f92672">=</span> start_x
</span></span><span style="display:flex;"><span>    accepted_count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n_iter):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># A. 从核中采样 (Proposal)</span>
</span></span><span style="display:flex;"><span>        x_star <span style="color:#f92672">=</span> sample_proposal_kernel(current_x, sigma)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># B. 计算接受率 (Symmetric Metropolis)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># alpha = min(1, pi(new) / pi(old))</span>
</span></span><span style="display:flex;"><span>        p_new <span style="color:#f92672">=</span> target_pdf(x_star)
</span></span><span style="display:flex;"><span>        p_old <span style="color:#f92672">=</span> target_pdf(current_x)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        alpha <span style="color:#f92672">=</span> min(<span style="color:#ae81ff">1</span>, p_new <span style="color:#f92672">/</span> p_old)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># C. 决策 (Decision)</span>
</span></span><span style="display:flex;"><span>        u <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>uniform(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> u <span style="color:#f92672">&lt;=</span> alpha:
</span></span><span style="display:flex;"><span>            current_x <span style="color:#f92672">=</span> x_star
</span></span><span style="display:flex;"><span>            accepted_count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        samples<span style="color:#f92672">.</span>append(current_x)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array(samples), accepted_count <span style="color:#f92672">/</span> n_iter
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 4. 运行模拟 ---</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">10000</span>
</span></span><span style="display:flex;"><span>start_x <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>  <span style="color:#75715e"># 从峡谷中间开始</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 实验 A: 窄核 (小步长) - 可能会被困住</span>
</span></span><span style="display:flex;"><span>samples_narrow, acc_narrow <span style="color:#f92672">=</span> continuous_metropolis(N, start_x, sigma<span style="color:#f92672">=</span><span style="color:#ae81ff">0.2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 实验 B: 宽核 (适中步长) - 能跨越峡谷</span>
</span></span><span style="display:flex;"><span>samples_wide, acc_wide <span style="color:#f92672">=</span> continuous_metropolis(N, start_x, sigma<span style="color:#f92672">=</span><span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 5. 可视化对比 ---</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">8</span>))
</span></span><span style="display:flex;"><span>x_axis <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#f92672">-</span><span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">1000</span>)
</span></span><span style="display:flex;"><span>y_truth <span style="color:#f92672">=</span> target_pdf(x_axis)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 简单归一化一下用于画图对比</span>
</span></span><span style="display:flex;"><span>y_truth <span style="color:#f92672">/=</span> np<span style="color:#f92672">.</span>trapezoid(y_truth, x_axis)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 图 1: 窄核 (Sigma=0.2)</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(samples_narrow, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;orange&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;A. Narrow Kernel (sigma=0.2)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Acc Rate: </span><span style="color:#e6db74">{</span>acc_narrow<span style="color:#e6db74">:</span><span style="color:#e6db74">.1%</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Position x&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>hist(samples_narrow, bins<span style="color:#f92672">=</span><span style="color:#ae81ff">50</span>, density<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;orange&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Samples&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(x_axis, y_truth, <span style="color:#e6db74">&#39;r-&#39;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Target&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Distribution (Trapped in one peak?)&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 图 2: 宽核 (Sigma=1.5)</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(samples_wide, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;B. Wide Kernel (sigma=1.5)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Acc Rate: </span><span style="color:#e6db74">{</span>acc_wide<span style="color:#e6db74">:</span><span style="color:#e6db74">.1%</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Position x&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>subplot(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>hist(samples_wide, bins<span style="color:#f92672">=</span><span style="color:#ae81ff">50</span>, density<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Samples&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(x_axis, y_truth, <span style="color:#e6db74">&#39;r-&#39;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Target&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Distribution (Good Mixing)&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="/img/contents/post/mcmc-statics/6_metropolis/6_mcmc_metropolis_9_0.png" alt="png"></p>
<p>结果解析：</p>
<ol>
<li>窄核 (Narrow Kernel, $\sigma=0.2$)
<ul>
<li>轨迹图 (左上): 你可能会看到小人一直待在 $x=0$ 附近，或者一旦滑入左边的山谷（$x=-2$），就再也跳不到右边的山谷（$x=2$）了。</li>
<li>分布图 (左下): 直方图可能只有单峰。</li>
<li>数学解释: 高斯核的尾巴太细了。要从 $-2$ 跳到 $2$，距离是 4。对于 $\sigma=0.2$ 的高斯分布来说，跳出 $4\sigma$ 以外的概率微乎其微。</li>
</ul>
</li>
<li>宽核 (Wide Kernel, $\sigma=1.5$)
<ul>
<li>轨迹图 (右上): 你会看到小人在 $-2$ 和 $2$ 之间反复横跳。</li>
<li>分布图 (右下): 完美复现了双峰结构。</li>
<li>数学解释: 此时的高斯核足够宽，使得从一个山头“探”到另一个山头的概率变得可观，从而实现了全局遍历。</li>
</ul>
</li>
</ol>
<h2 id="的选择">$Q$ 的选择</h2>
<p>在 Metropolis 算法（对称提议）的框架下，选择 $Q$ 主要有三个维度的考量：尺度 (Scale)、形状 (Shape) 和 方向 (Orientation)。</p>
<h3 id="尺度-scale步子该迈多大">尺度 (Scale)：步子该迈多大？</h3>
<p>这是最基础的问题，也就是在上一个代码中看到的 sigma。</p>
<ul>
<li>过小 ($\sigma \ll$ 目标宽度)：
<ul>
<li>现象：接受率极高（接近 100%），但轨迹像爬行的蜗牛。</li>
<li>术语：<strong>随机游走行为 (Random Walk Behavior)</strong>。</li>
<li>代价：你需要 $N^2$ 步才能走过距离 $N$。</li>
</ul>
</li>
<li>过大 ($\sigma \gg$ 目标宽度)：
<ul>
<li>现象：接受率极低（接近 0%），轨迹像心电图停搏。</li>
<li>原因：你总是试图从高概率区跳到极低概率区（荒野），然后被拒绝。</li>
</ul>
</li>
<li>黄金标准 (Goldilocks Zone)：
<ul>
<li>对于高维高斯目标分布，理论证明最佳接受率约为 23.4% ($0.234$)。</li>
<li>对于 1 维问题，通常在 40% ~ 50% 左右比较好。</li>
</ul>
</li>
<li>💡 调参策略： 自适应 MCMC (Adaptive MCMC)。先跑一小段，如果接受率 $<10\%$，就把 $\sigma$ 减小；如果 $>60\%$，就把 $\sigma$ 增大。</li>
</ul>
<h3 id="形状-shape尾巴该有多长">形状 (Shape)：尾巴该有多长？</h3>
<p>默认我们都用 <strong>高斯分布 (Normal Distribution)</strong> 作为核，但它有一个致命弱点：<strong>轻尾 (Light-tailed)</strong>。</p>
<p>高斯分布的概率密度在远离中心时下降得极快（指数级下降）。这意味着它极度厌恶产生“大跳跃”。</p>
<ul>
<li>场景：刚才的“双峰”问题。如果两座山峰隔得很远（比如距离 $10\sigma$），高斯核产生的提议几乎永远无法跨越这个峡谷。</li>
<li>解法：使用 <strong>柯西分布 (Cauchy Distribution) 或 t-分布</strong>。
<ul>
<li>在 python 中就是 <code>np.random.standard_cauchy</code></li>
<li>柯西分布的密度函数是 $\frac{1}{1+x^2}$（多项式级下降），它的尾巴非常“肥”。</li>
<li>效果：它大部分时候迈小步（局部搜索），但偶尔会发疯似地迈出巨大的一步（全局跳跃）。这对于跳出局部最优陷阱极其有效。</li>
</ul>
</li>
</ul>
<h3 id="方向-orientation如何穿越峡谷">方向 (Orientation)：如何穿越峡谷？</h3>
<p>假设目标分布是一个细长的椭圆（两个变量高度相关），就像一条倾斜的峡谷。</p>
<ul>
<li>这种分布的特点：
<ul>
<li>沿着峡谷方向（长轴）：变化很慢，地势平坦。</li>
<li>垂直峡谷方向（短轴）：变化极快，稍微偏一点就掉下悬崖（概率骤降）。</li>
</ul>
</li>
<li>如果你用标准的高斯核 (各向同性, Isotropic)：
<ul>
<li>你的 $Q$ 是一个正圆。</li>
<li>如果你把圆弄大（为了沿长轴走得快），你在短轴方向就会频繁撞墙（掉下悬崖），导致被拒绝。</li>
<li>如果你把圆弄小（为了在短轴方向安全），你在长轴方向就走不动了。</li>
</ul>
</li>
<li>解法：<strong>预处理 (Preconditioning) 或 协方差矩阵 (Covariance Matrix)</strong>。
<ul>
<li>我们希望 $Q$ 的形状也是一个倾斜的椭圆，和目标分布的方向一致。</li>
<li>数学上，设目标协方差为 $\Sigma$，我们让提议分布为 $q(\cdot|x) \sim N(x, c^2 \Sigma)$。</li>
<li>这相当于先把坐标系旋转、缩放，把峡谷变成正圆，然后再采样。</li>
</ul>
</li>
</ul>
<h1 id="收敛-convergence-和-混合-mixing">收敛 (Convergence) 和 混合 (Mixing)</h1>
<h2 id="什么是-mixing-混合">什么是 Mixing (混合)？</h2>
<p>简单来说，Mixing 就是链条“忘掉”它从哪里出发、并完全融入目标分布的速度。</p>
<p>把它想象成往咖啡里倒牛奶：</p>
<ul>
<li>刚开始 (未混合)： 牛奶只在杯子的一角，浓度极不均匀（链条受初始值影响很大，还在赶路）。</li>
<li>搅拌中 (混合慢 - Slow Mixing)： 你用很细的牙签慢慢划拉。牛奶在扩散，但很慢。你需要搅很久，杯子各处的牛奶浓度才一样。</li>
<li>搅拌好 (混合快 - Fast Mixing)： 你用大勺子猛搅几下。牛奶瞬间均匀分布。此时你随便舀一勺，都代表了整杯咖啡的平均状态。</li>
</ul>
<p>在 MCMC 中：</p>
<ul>
<li>Good Mixing: 无论你把小人扔在哪里，它能迅速跑遍整个地形（遍历性），且第 100 步的位置和第 1 步的位置几乎没有关系（<strong>独立性</strong>）。</li>
<li>Bad Mixing: 小人要么被困在某个山头出不去（Stiff），要么走得太慢（Smooth），导致它采集的样本严重依赖于它刚才所在的位置。</li>
</ul>
<blockquote>
<p>衡量混合好坏的最佳标尺就是 <strong>自相关性 (Autocorrelation)</strong>。</p></blockquote>
<h2 id="核心度量工具自相关函数-acf">核心度量工具：自相关函数 (ACF)</h2>
<p>首先，我们要量化“当前这一步 $X_t$ 和它之前的某一步 $X_{t-k}$ 到底有多像”。这就是 <strong>Autocorrelation Function (ACF)</strong>。</p>
<ul>
<li>Lag $k$ (滞后)：表示相隔 $k$ 步。</li>
<li>$\rho_k$ (自相关系数)：
<ul>
<li>$\rho_k \approx 1$：强相关。今天的状态几乎完全由 $k$ 天前决定（坏事，说明没忘掉过去）。</li>
<li>$\rho_k \approx 0$：无相关。今天的状态和 $k$ 天前无关（好事，说明是独立样本）。</li>
</ul>
</li>
</ul>
<p>我们在诊断时，会画一张 ACF 图：横轴是 $k$，纵轴是 $\rho_k$。我们希望 $\rho_k$ 像悬崖一样快速掉到 0。</p>
<h3 id="场景-a-the-smooth-chain-平滑链--步长太小">场景 A: The Smooth Chain (平滑链 / 步长太小)</h3>
<blockquote>
<p>&ldquo;Smooth $\to$ Long correlation&rdquo;。</p></blockquote>
<ul>
<li>现象： 步长 $\sigma$ 很小，接受率极高（$\approx 90\%$）。</li>
<li>轨迹图表现： 线条连续、圆滑，像一条蜿蜒的长蛇。</li>
<li>物理机制（随机游走）：$$X_{t+1} = X_t + \epsilon \quad (\epsilon \text{ is tiny})$$虽然每一步都被接受了，但 $X_{t+1}$ 和 $X_t$ 长得几乎一模一样。</li>
<li>Correlation 分析：
<ul>
<li>你要花 1000 步才能从分布的左边走到右边。</li>
<li>这意味着 $X_{1000}$ 依然能在某种程度上预测 $X_{1001}$。</li>
<li>ACF 图： $\rho_k$ 下降极慢（Slow decay）。哪怕 $k=100$，相关性可能还有 0.8。结论：</li>
</ul>
</li>
<li>混合极差 (Poor Mixing)。虽然在动，但动得太墨迹。</li>
</ul>
<h3 id="场景-b-the-stiff-chain-僵硬链--步长太大">场景 B: The Stiff Chain (僵硬链 / 步长太大)</h3>
<p>通常“步长极大”会导致接受率极低（$\approx 1\%$）。</p>
<ul>
<li>现象： 提议 $X_{new}$ 总是跳到很远的地方（概率极低区），然后被拒绝。</li>
<li>轨迹图表现： 方波 (Square Wave)。长时间是一条直线（僵硬、卡死），偶尔跳变一下。物理机制（拒绝即重复）：$$X_{t+1} = X_t \quad (\text{因为拒绝})$$注意！当拒绝发生时，我们必须记录旧值。</li>
<li>Correlation 分析：
<ul>
<li>你以为步子大，样本之间就没关系了吗？</li>
<li>错！因为大部分时间你都在 <strong>重复同一个数字</strong>。$X_t, X_{t+1}, \dots, X_{t+10}$ 全是同一个数值。这不仅仅是相关，这是完全相同！</li>
<li>ACF 图： $\rho_k$ 依然很高，甚至比 Smooth 的情况更难看，因为它包含长段的 $1.0$ 相关性。</li>
</ul>
</li>
<li>结论： 混合也极差。这种“僵硬”导致的短视（Short correlation）只存在于“提议”阶段，但在“接受”后的链条里，它是强相关的。</li>
</ul>
<h3 id="黄金平衡有效样本量-ess">黄金平衡：有效样本量 (ESS)</h3>
<p>既然“太顺滑”不行（相关性高），“太僵硬”也不行（重复率高，相关性也高）。我们要追求中间态。我们用一个核心指标来给链条打分：<strong>有效样本量 (Effective Sample Size, ESS)</strong>。</p>
<p>假设你跑了 $N = 10,000$ 步。</p>
<ul>
<li>如果是 Smooth 链： 样本高度相关，这 1万个样本包含的信息量，可能只相当于 50 个 独立样本。</li>
<li>如果是 Stiff 链： 大部分样本是重复的，信息量可能只相当于 10 个 独立样本。</li>
<li>如果是 Optimal 链： 2-3 步就能忘掉过去，信息量可能相当于 3,000 个 独立样本。公式：$$N_{eff} = \frac{N}{1 + 2 \sum_{k=1}^{\infty} \rho_k}$$（分母就是 Integrated Autocorrelation Time, $\tau$，也就是“产生一个独立样本平均需要多少步”）</li>
</ul>
<h3 id="相关性的-u-型曲线">相关性的 U 型曲线</h3>
<p>如果我们将 步长 (Step Size $\sigma$) 作为横轴，自相关时间 ($\tau$) 作为纵轴，会得到一条 U 型曲线。</p>
<ul>
<li>左侧 (Small $\sigma$)： Smooth。接受率高，但单步位移小。$\tau$ 很高（慢）。</li>
<li>右侧 (Large $\sigma$)： Stiff。单步位移大，但接受率低（老是被拒，老是重复）。$\tau$ 很高（慢）。</li>
<li>谷底 (Optimal $\sigma$)： Sweet Spot。
<ul>
<li>接受率控制在 23.4% (高维) 或 40-50% (1维)。</li>
<li>ACF 像瀑布一样迅速掉到 0。</li>
<li>这就是所谓的 &ldquo;Good Mixing&rdquo;。</li>
</ul>
</li>
</ul>
<h3 id="示例三张-acf-图">示例：三张 ACF 图</h3>
<p>用 Python 模拟一个简单的 标准正态分布采样，并画出Smooth (步长小) vs Stiff (步长很大) vs Optimal (步长适中)的 轨迹图 (Trace Plot) 和 自相关图 (ACF Plot)。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> statsmodels.api <span style="color:#66d9ef">as</span> sm
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 1. 准备工作 ---</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 目标：标准正态分布 N(0, 1)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">target_log_prob</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> x<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Metropolis 采样核</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run_chain</span>(n_steps, step_size, start_x<span style="color:#f92672">=</span><span style="color:#ae81ff">0.0</span>):
</span></span><span style="display:flex;"><span>    samples <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(n_steps)
</span></span><span style="display:flex;"><span>    current_x <span style="color:#f92672">=</span> start_x
</span></span><span style="display:flex;"><span>    accepted <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_steps):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 提议</span>
</span></span><span style="display:flex;"><span>        proposal <span style="color:#f92672">=</span> current_x <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(<span style="color:#ae81ff">0</span>, step_size)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 接受率 (Log scale for stability)</span>
</span></span><span style="display:flex;"><span>        log_alpha <span style="color:#f92672">=</span> target_log_prob(proposal) <span style="color:#f92672">-</span> target_log_prob(current_x)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># min(1, A) -&gt; min(0, log_A) in log domain</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> np<span style="color:#f92672">.</span>log(np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand()) <span style="color:#f92672">&lt;</span> log_alpha:
</span></span><span style="display:flex;"><span>            current_x <span style="color:#f92672">=</span> proposal
</span></span><span style="display:flex;"><span>            accepted <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        samples[i] <span style="color:#f92672">=</span> current_x
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    acc_rate <span style="color:#f92672">=</span> accepted <span style="color:#f92672">/</span> n_steps
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> samples, acc_rate
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 2. 运行三种场景 ---</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">2000</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># A. Smooth (步长太小)</span>
</span></span><span style="display:flex;"><span>chain_smooth, acc_smooth <span style="color:#f92672">=</span> run_chain(N, step_size<span style="color:#f92672">=</span><span style="color:#ae81ff">0.1</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># B. Stiff (步长太大)</span>
</span></span><span style="display:flex;"><span>chain_stiff, acc_stiff <span style="color:#f92672">=</span> run_chain(N, step_size<span style="color:#f92672">=</span><span style="color:#ae81ff">50.0</span>)
</span></span><span style="display:flex;"><span><span style="color:#75715e"># C. Optimal (步长适中)</span>
</span></span><span style="display:flex;"><span>chain_optimal, acc_optimal <span style="color:#f92672">=</span> run_chain(N, step_size<span style="color:#f92672">=</span><span style="color:#ae81ff">2.4</span>) <span style="color:#75715e"># 对于1维高斯，大一点没事</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 3. 绘图对比 (Trace + ACF) ---</span>
</span></span><span style="display:flex;"><span>fig, axes <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">10</span>))
</span></span><span style="display:flex;"><span>lags <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span> <span style="color:#75715e"># 看前100步的相关性</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 辅助函数：画一行图</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_row</span>(row_idx, samples, acc, title, color):
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 左边：Trace Plot</span>
</span></span><span style="display:flex;"><span>    ax_trace <span style="color:#f92672">=</span> axes[row_idx, <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    ax_trace<span style="color:#f92672">.</span>plot(samples, color<span style="color:#f92672">=</span>color, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    ax_trace<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>title<span style="color:#e6db74">}</span><span style="color:#e6db74"> - Trace (Acc: </span><span style="color:#e6db74">{</span>acc<span style="color:#e6db74">:</span><span style="color:#e6db74">.1%</span><span style="color:#e6db74">}</span><span style="color:#e6db74">)&#34;</span>)
</span></span><span style="display:flex;"><span>    ax_trace<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;Value&#34;</span>)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 右边：ACF Plot</span>
</span></span><span style="display:flex;"><span>    ax_acf <span style="color:#f92672">=</span> axes[row_idx, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># 使用 statsmodels 计算 ACF</span>
</span></span><span style="display:flex;"><span>    acf_values <span style="color:#f92672">=</span> sm<span style="color:#f92672">.</span>tsa<span style="color:#f92672">.</span>acf(samples, nlags<span style="color:#f92672">=</span>lags)
</span></span><span style="display:flex;"><span>    ax_acf<span style="color:#f92672">.</span>bar(range(len(acf_values)), acf_values, width<span style="color:#f92672">=</span><span style="color:#ae81ff">0.3</span>, color<span style="color:#f92672">=</span>color, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.7</span>)
</span></span><span style="display:flex;"><span>    ax_acf<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{</span>title<span style="color:#e6db74">}</span><span style="color:#e6db74"> - Autocorrelation&#34;</span>)
</span></span><span style="display:flex;"><span>    ax_acf<span style="color:#f92672">.</span>set_ylim(<span style="color:#f92672">-</span><span style="color:#ae81ff">0.1</span>, <span style="color:#ae81ff">1.1</span>)
</span></span><span style="display:flex;"><span>    ax_acf<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;Correlation&#34;</span>)
</span></span><span style="display:flex;"><span>    ax_acf<span style="color:#f92672">.</span>axhline(<span style="color:#ae81ff">0.05</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;gray&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>) <span style="color:#75715e"># 显著性阈值</span>
</span></span><span style="display:flex;"><span>    ax_acf<span style="color:#f92672">.</span>axhline(<span style="color:#ae81ff">0</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;black&#39;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 绘制三行</span>
</span></span><span style="display:flex;"><span>plot_row(<span style="color:#ae81ff">0</span>, chain_smooth, acc_smooth, <span style="color:#e6db74">&#34;A. Smooth (Step=0.1)&#34;</span>, <span style="color:#e6db74">&#34;orange&#34;</span>)
</span></span><span style="display:flex;"><span>plot_row(<span style="color:#ae81ff">1</span>, chain_stiff, acc_stiff, <span style="color:#e6db74">&#34;B. Stiff (Step=50)&#34;</span>, <span style="color:#e6db74">&#34;purple&#34;</span>)
</span></span><span style="display:flex;"><span>plot_row(<span style="color:#ae81ff">2</span>, chain_optimal, acc_optimal, <span style="color:#e6db74">&#34;C. Optimal (Step=2.4)&#34;</span>, <span style="color:#e6db74">&#34;green&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>tight_layout()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="/img/contents/post/mcmc-statics/6_metropolis/6_mcmc_metropolis_14_0.png" alt="png"></p>
<p><strong>A. Smooth (橙色) —— 步长太小</strong></p>
<ul>
<li>Trace (左): 像一条蜿蜒的蛇，爬得很慢。</li>
<li>ACF (右): 长长的拖尾 (Slow Decay)。
<ul>
<li>即使到了 Lag=100（相隔100步），相关性可能还有 0.8 或 0.9。</li>
<li>含义： “我记得我祖宗十八代的样貌”。第 100 步的状态依然强烈依赖于第 1 步。这意味着虽然你跑了 2000 步，但有效样本量（独立样本）可能只有几十个。Mixing 很差。</li>
</ul>
</li>
</ul>
<p><strong>B. Stiff (紫色) —— 步长太大</strong></p>
<ul>
<li>Trace (左): 方波/心电图。长时间卡在一个值不动（拒绝），偶尔跳一下。</li>
<li>ACF (右): 同样是长拖尾，甚至更严重。
<ul>
<li>你会发现相关性并不是像 Smooth 那样平滑下降，而是可能在一大段 Lag 内都维持在很高水平（因为数值根本没变，相关性当然是 1.0）。</li>
<li>含义： “我不仅记得过去，我简直就是过去的复制品”。由于大量重复值，信息量极低。Mixing 也很差。</li>
</ul>
</li>
</ul>
<p><strong>C. Optimal (绿色) —— 黄金步长</strong></p>
<ul>
<li>Trace (左): 毛毛虫。围绕 0 剧烈震荡，看不出趋势。</li>
<li>ACF (右): 断<strong>崖式下跌 (Fast Decay)</strong>。
<ul>
<li>Lag=0 时是 1.0（自己跟自己肯定相关）。</li>
<li>Lag=5 或 10 左右，柱子就迅速掉到了 0 附近（虚线区域）。</li>
<li>含义： “好汉不提当年勇”。仅仅走了几步，链条就完全忘记了刚才在哪里。这说明每隔几步我们就能获得一个全新的、独立的有效样本。这就是 Perfect Mixing！</li>
</ul>
</li>
</ul>
<h1 id="burn-in预热--老化">Burn-in（预热 / 老化）</h1>
<p><strong>Burn-in 指的是在 MCMC 采样开始后，我们要直接丢弃掉的前面 $N$ 个样本。</strong></p>
<p>比如你让程序跑了 10,000 步，但你可能只保留第 1,001 步到第 10,000 步的数据。前 1,000 个样本就是 Burn-in 期，直接扔进垃圾桶。🗑️</p>
<h2 id="为什么要扔掉它们the-bias-problem">为什么要扔掉它们？(The Bias Problem)</h2>
<p>因为 MCMC 算法有一个 <strong>“初始化偏见” (Initialization Bias)</strong> 的问题。</p>
<p>想象你要统计一个万人体育馆里观众的平均身高：</p>
<ol>
<li>随机空降： 你不可能直接空降到人最密集的地方。程序初始化时，通常是随机猜一个起点（比如 $x_0 = 100$）。</li>
<li>爬山赶路： 假设目标分布（大部分人）都在 $x=0$ 附近。你的采样器从小人从 $x=100$ 出发，它需要一步一步“爬”到 $x=0$ 的区域。</li>
<li>垃圾时间： 在它从 100 走到 0 的这段路程中，它记录的样本是：99, 98, &hellip;, 50, &hellip;, 10, &hellip;。
<ul>
<li>问题来了： 这些数值根本不属于目标分布（$N(0,1)$）！它们只是小人“赶路”留下的脚印。</li>
<li>后果： 如果你把这些赶路的数据算进平均值，你的结果就会被严重拉高（偏离真实值）。</li>
</ul>
</li>
</ol>
<p>Burn-in 的作用就是： 等小人真正走到了体育馆中心（进入了平稳分布 Stationary Distribution），我们才开始按下录像键。之前的赶路过程统统剪掉。</p>
<h2 id="python-视觉实战看见-burn-in">Python 视觉实战：看见 Burn-in</h2>
<p>模拟一个标准正态分布（中心在 0），但我们将起点故意设在极远的地方 ($x=20$)，并且让步长稍微小一点（模拟走得慢的情况）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 1. 目标：标准正态分布 N(0, 1)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">target_log_prob</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5</span> <span style="color:#f92672">*</span> x<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 2. 模拟采样</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run_burnin_demo</span>(n_steps, start_x, step_size):
</span></span><span style="display:flex;"><span>    samples <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(n_steps)
</span></span><span style="display:flex;"><span>    current_x <span style="color:#f92672">=</span> start_x
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n_steps):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 提议</span>
</span></span><span style="display:flex;"><span>        proposal <span style="color:#f92672">=</span> current_x <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>normal(<span style="color:#ae81ff">0</span>, step_size)
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># 接受率</span>
</span></span><span style="display:flex;"><span>        log_alpha <span style="color:#f92672">=</span> target_log_prob(proposal) <span style="color:#f92672">-</span> target_log_prob(current_x)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> np<span style="color:#f92672">.</span>log(np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand()) <span style="color:#f92672">&lt;</span> log_alpha:
</span></span><span style="display:flex;"><span>            current_x <span style="color:#f92672">=</span> proposal
</span></span><span style="display:flex;"><span>        samples[i] <span style="color:#f92672">=</span> current_x
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> samples
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 设置 ---</span>
</span></span><span style="display:flex;"><span>N <span style="color:#f92672">=</span> <span style="color:#ae81ff">1000</span>
</span></span><span style="display:flex;"><span>start_val <span style="color:#f92672">=</span> <span style="color:#ae81ff">20.0</span>  <span style="color:#75715e"># &lt;--- 起点离中心(0)非常远！</span>
</span></span><span style="display:flex;"><span>step <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.5</span>        <span style="color:#75715e"># 步长较小，走得慢</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>chain <span style="color:#f92672">=</span> run_burnin_demo(N, start_val, step)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># --- 绘图 ---</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">6</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 画出轨迹</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>plot(chain, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;MCMC Chain&#39;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;blue&#39;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">1.5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 标出 Burn-in 的分界线 (比如大约在第 200 步到达中心)</span>
</span></span><span style="display:flex;"><span>burn_in_cutoff <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axvline(x<span style="color:#f92672">=</span>burn_in_cutoff, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;--&#39;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Burn-in Cutoff&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 标注文字</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>text(<span style="color:#ae81ff">50</span>, <span style="color:#ae81ff">15</span>, <span style="color:#e6db74">&#34;Transient Phase</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">(Garbage Samples)&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;red&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bold&#39;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>text(<span style="color:#ae81ff">400</span>, <span style="color:#ae81ff">5</span>, <span style="color:#e6db74">&#34;Stationary Phase</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">(Valid Samples)&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;green&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>, fontweight<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;bold&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Visualizing Burn-in: Starting from x=</span><span style="color:#e6db74">{</span>start_val<span style="color:#e6db74">}</span><span style="color:#e6db74"> to target N(0,1)&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Iteration&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#34;Sample Value&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>axhline(<span style="color:#ae81ff">0</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;gray&#39;</span>, linestyle<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;:&#39;</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>) <span style="color:#75715e"># 目标均值</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend()
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>grid(<span style="color:#66d9ef">True</span>, alpha<span style="color:#f92672">=</span><span style="color:#ae81ff">0.3</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img src="/img/contents/post/mcmc-statics/6_metropolis/6_mcmc_metropolis_17_0.png" alt="png"></p>
<p>观察那条蓝线：</p>
<ul>
<li>左侧（红线左边）：
<ul>
<li>下坡路小人从 20 开始，一路跌跌撞撞往下掉。</li>
<li>这段时间的数据（比如 18, 15, 8&hellip;）全是垃圾。它们只反映了你的初始值设得有多偏，完全不代表 $N(0,1)$ 分布。</li>
<li>这就是 <strong>Burn-in Period</strong>。</li>
</ul>
</li>
<li>右侧（红线右边）：
<ul>
<li>毛毛虫大约在第 200 步左右，小人终于到达了 0 附近。</li>
<li>之后的轨迹开始围绕 0 上下震荡，看不出任何趋势。</li>
<li>这时候，链条才真正 **收敛（Converged）**到了目标分布。这之后的数据才是我们能用的。</li>
</ul>
</li>
</ul>
<h2 id="burn-in-要设多长">Burn-in 要设多长？</h2>
<p>这是 MCMC 调参中最玄学的问题之一。</p>
<ul>
<li><strong>看图法</strong>（最常用）： 画出 Trace Plot（就像上面那样）。肉眼观察曲线什么时候不再有明显的上升或下降趋势，开始变得像毛毛虫一样平稳震荡。</li>
<li>保守法： <strong>直接扔掉前 50% 的样本</strong>。反正现在的电脑算力便宜，多扔点不心疼，总比保留了垃圾数据强。</li>
<li>关联之前的知识：
<ul>
<li>如果步长太小（Smooth Chain），小人走得慢，从 20 走到 0 需要很久 $\to$ 需要很长的 Burn-in。</li>
<li>如果混合得好（Optimal Chain），小人几步就跳过去了 $\to$ 只需要很短的 Burn-in。</li>
</ul>
</li>
</ul>


        
          <div class="blog-tags">
            
              <a href="http://localhost:1313/zh-cn/tags/mcmc/">MCMC</a>&nbsp;
            
              <a href="http://localhost:1313/zh-cn/tags/metropolis%E7%AE%97%E6%B3%95/">Metropolis算法</a>&nbsp;
            
              <a href="http://localhost:1313/zh-cn/tags/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%A8%A1%E6%8B%9F/">蒙特卡洛模拟</a>&nbsp;
            
              <a href="http://localhost:1313/zh-cn/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%BB%9F%E8%AE%A1/">贝叶斯统计</a>&nbsp;
            
              <a href="http://localhost:1313/zh-cn/tags/python%E5%AE%9E%E7%8E%B0/">Python实现</a>&nbsp;
            
              <a href="http://localhost:1313/zh-cn/tags/%E9%9A%8F%E6%9C%BA%E6%B8%B8%E8%B5%B0/">随机游走</a>&nbsp;
            
          </div>
        

        
            <hr/>
            <section id="social-share">
              <div class="list-inline footer-links">
                

<div class="share-box" aria-hidden="true">
  <ul class="share">
    
    <li>
      <a
        href="//twitter.com/share?url=http%3a%2f%2flocalhost%3a1313%2fzh-cn%2fpost%2fmcmc-statics%2fmetropolis%2f&amp;text=Metropolis%20%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%8e%9f%e7%90%86%e5%88%b0%20Python%20%e5%ae%9e%e7%8e%b0&amp;via="
        target="_blank"
        title="Share on Twitter"
        class="share-btn twitter"
      >
        <i class="fab fa-twitter"></i>
      </a>
    </li>

    
    <li>
      <a
        href="//www.facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fzh-cn%2fpost%2fmcmc-statics%2fmetropolis%2f"
        target="_blank"
        title="Share on Facebook"
        class="share-btn facebook"
      >
        <i class="fab fa-facebook"></i>
      </a>
    </li>

    
    <li>
      <a
        href="//service.weibo.com/share/share.php?url=http%3a%2f%2flocalhost%3a1313%2fzh-cn%2fpost%2fmcmc-statics%2fmetropolis%2f&amp;appkey=&amp;title=Metropolis%20%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%8e%9f%e7%90%86%e5%88%b0%20Python%20%e5%ae%9e%e7%8e%b0&amp;pic="
        target="_blank"
        title="Share on Weibo"
        class="share-btn weibo"
      >
        <i class="fab fa-weibo"></i>
      </a>
    </li>

    
    <li>
      <a
        href="javascript:void(0);"
        onclick="openWechatModal('http:\/\/localhost:1313\/zh-cn\/post\/mcmc-statics\/metropolis\/')"
        title="Share on WeChat"
        class="share-btn wechat"
      >
        <i class="fab fa-weixin"></i>
      </a>
    </li>

    
    <li>
      <a
        href="//www.linkedin.com/shareArticle?url=http%3a%2f%2flocalhost%3a1313%2fzh-cn%2fpost%2fmcmc-statics%2fmetropolis%2f&amp;title=Metropolis%20%e7%ae%97%e6%b3%95%e8%af%a6%e8%a7%a3%ef%bc%9a%e4%bb%8e%e5%8e%9f%e7%90%86%e5%88%b0%20Python%20%e5%ae%9e%e7%8e%b0"
        target="_blank"
        title="Share on LinkedIn"
        class="share-btn linkedin"
      >
        <i class="fab fa-linkedin"></i>
      </a>
    </li>

    
    <li>
      <a
        href="javascript:void(0);"
        onclick="copyToClipboard('http:\/\/localhost:1313\/zh-cn\/post\/mcmc-statics\/metropolis\/', 'Metropolis 算法详解：从原理到 Python 实现')"
        title="Copy Link"
        class="share-btn copy-link"
      >
        <i class="fas fa-link"></i>
      </a>
    </li>
  </ul>
</div>


<div id="wechat-modal" class="wechat-modal">
  <div class="wechat-modal-content">
    <span class="wechat-close" onclick="closeWechatModal()">&times;</span>
    <h4>
      Scan to Share <br />
      微信扫一扫分享
    </h4>
    <div id="qrcode" class="qrcode-container"></div>
  </div>
</div>

<script type="text/javascript">
  function copyToClipboard(url, title) {
    navigator.clipboard.writeText(url).then(
      function () {
        
        var existingToast = document.getElementById("share-toast");
        if (existingToast) {
          existingToast.remove();
        }

        var toast = document.createElement("div");
        toast.id = "share-toast";
        toast.innerText = "Link copied to clipboard!";
        toast.style.position = "fixed";
        toast.style.bottom = "20px";
        toast.style.left = "50%";
        toast.style.transform = "translateX(-50%)";
        toast.style.backgroundColor = "rgba(0,0,0,0.8)";
        toast.style.color = "#fff";
        toast.style.padding = "10px 20px";
        toast.style.borderRadius = "5px";
        toast.style.zIndex = "10000";
        toast.style.opacity = "0";
        toast.style.transition = "opacity 0.5s ease-in-out";

        document.body.appendChild(toast);

        
        void toast.offsetWidth;

        toast.style.opacity = "1";

        setTimeout(function () {
          toast.style.opacity = "0";
          setTimeout(function () {
            if (toast.parentNode) toast.parentNode.removeChild(toast);
          }, 500);
        }, 3000);
      },
      function (err) {
        console.error("Could not copy text: ", err);
      },
    );
  }

  function openWechatModal(url) {
    var modal = document.getElementById("wechat-modal");
    modal.style.display = "flex";
    var qrcodeContainer = document.getElementById("qrcode");
    qrcodeContainer.innerHTML = "";
    var img = document.createElement("img");
    img.src =
      "https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=" +
      encodeURIComponent(url);
    img.style.width = "200px";
    img.style.height = "200px";
    qrcodeContainer.appendChild(img);
  }

  function closeWechatModal() {
    var modal = document.getElementById("wechat-modal");
    modal.style.display = "none";
  }

  
  window.onclick = function (event) {
    var modal = document.getElementById("wechat-modal");
    if (event.target == modal) {
      modal.style.display = "none";
    }
  };
</script>


              </div>
            </section>
        

        
          
            
          

          
                  <h4 class="see-also">也可以看看</h4>
                  <ul>
                
                
                    <li><a href="/zh-cn/post/mcmc-statics/gibbs-sampling/">Gibbs 采样详解：分而治之的降维智慧</a></li>
                
                    <li><a href="/zh-cn/post/mcmc-statics/metropolis-hastings/">Metropolis-Hastings 算法：打破对称性的束缚</a></li>
                
              </ul>

          
        
      </article>

      
        <ul class="pager blog-pager">
          
            <li class="previous">
              <a href="http://localhost:1313/zh-cn/post/mcmc-statics/markov-chains/" data-toggle="tooltip" data-placement="top" title="理解马尔可夫链">&larr; 前一篇</a>
            </li>
          
          
            <li class="next">
              <a href="http://localhost:1313/zh-cn/post/mcmc-statics/metropolis-hastings/" data-toggle="tooltip" data-placement="top" title="Metropolis-Hastings 算法：打破对称性的束缚">后一篇 &rarr;</a>
            </li>
          
        </ul>
      


      

    </div>
    
    
    <div class="col-lg-3 visible-lg-block">
      
      
      <div class="sidebar-toc">
        <h2 class="sidebar-toc-title">目录</h2>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#我们要解决什么问题the-core-problem">我们要解决什么问题？(The Core Problem)</a>
      <ul>
        <li><a href="#1-核心困境无法计算的">1. 核心困境：无法计算的 </a>
          <ul>
            <li><a href="#关于">关于 </a></li>
          </ul>
        </li>
        <li><a href="#2-metropolis-的解决策略相对比值法">2. Metropolis 的解决策略：相对比值法</a></li>
        <li><a href="#3-连接点为什么要用马尔可夫链">3. 连接点：为什么要用马尔可夫链？</a></li>
      </ul>
    </li>
    <li><a href="#metropolis随机游走">Metropolis（随机游走）</a>
      <ul>
        <li><a href="#三个版本的接受率">三个版本的接受率 </a>
          <ul>
            <li><a href="#版本一metropolis-选择-the-metropolis-choice">版本一：Metropolis 选择 (The Metropolis Choice)</a></li>
            <li><a href="#版本-二barker-选择-the-barker-choice--glauber-dynamics">版本 二：Barker 选择 (The Barker Choice / Glauber Dynamics)</a></li>
            <li><a href="#版本三metropolis-hastings-mh-接受率">版本三：Metropolis-Hastings (MH) 接受率</a></li>
          </ul>
        </li>
        <li><a href="#算法流程">算法流程</a>
          <ul>
            <li><a href="#离散-metropolis-算法">离散 Metropolis 算法</a></li>
            <li><a href="#连续-metropolis-算法">连续 Metropolis 算法</a></li>
          </ul>
        </li>
        <li><a href="#的选择"> 的选择</a>
          <ul>
            <li><a href="#尺度-scale步子该迈多大">尺度 (Scale)：步子该迈多大？</a></li>
            <li><a href="#形状-shape尾巴该有多长">形状 (Shape)：尾巴该有多长？</a></li>
            <li><a href="#方向-orientation如何穿越峡谷">方向 (Orientation)：如何穿越峡谷？</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#收敛-convergence-和-混合-mixing">收敛 (Convergence) 和 混合 (Mixing)</a>
      <ul>
        <li><a href="#什么是-mixing-混合">什么是 Mixing (混合)？</a></li>
        <li><a href="#核心度量工具自相关函数-acf">核心度量工具：自相关函数 (ACF)</a>
          <ul>
            <li><a href="#场景-a-the-smooth-chain-平滑链--步长太小">场景 A: The Smooth Chain (平滑链 / 步长太小)</a></li>
            <li><a href="#场景-b-the-stiff-chain-僵硬链--步长太大">场景 B: The Stiff Chain (僵硬链 / 步长太大)</a></li>
            <li><a href="#黄金平衡有效样本量-ess">黄金平衡：有效样本量 (ESS)</a></li>
            <li><a href="#相关性的-u-型曲线">相关性的 U 型曲线</a></li>
            <li><a href="#示例三张-acf-图">示例：三张 ACF 图</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#burn-in预热--老化">Burn-in（预热 / 老化）</a>
      <ul>
        <li><a href="#为什么要扔掉它们the-bias-problem">为什么要扔掉它们？(The Bias Problem)</a></li>
        <li><a href="#python-视觉实战看见-burn-in">Python 视觉实战：看见 Burn-in</a></li>
        <li><a href="#burn-in-要设多长">Burn-in 要设多长？</a></li>
      </ul>
    </li>
  </ul>
</nav>
      </div>
      
    </div>
    
  </div>
</div>

      <footer>
  <div class="container">
    
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center footer-links">
          
              <li>
		
		  <a href="mailto:ele.qiong@gmail.com" title="Email me">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fas fa-envelope fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://github.com/ictar" title="GitHub">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
              <li>
		
		  <a href="https://linkedin.com/in/qiongjie-xu" title="LinkedIn">
		
                  <span class="fa-stack fa-lg">
                    <i class="fas fa-circle fa-stack-2x"></i>
                    <i class="fab fa-linkedin fa-stack-1x fa-inverse"></i>
                  </span>
                </a>
              </li>
          
          
          
        </ul>
        <p class="credits copyright text-muted">
          
            
              <a href="https://www.xuqiongjie.com">Qiongjie.X</a>
            
          

          &nbsp;&bull;&nbsp;&copy;
          
            2026
          

          
            &nbsp;&bull;&nbsp;
            <a href="http://localhost:1313/zh-cn/">琼呀</a>
          
        </p>
        
        <p class="credits theme-by text-muted">
          由 <a href="https://gohugo.io">Hugo v0.147.4</a> 强力驱动 &nbsp;&bull;&nbsp; 主题 <a href="https://github.com/halogenica/beautifulhugo">Beautiful Hugo</a> 移植自 <a href="https://deanattali.com/beautiful-jekyll/">Beautiful Jekyll</a>
          
        </p>
      </div>
    </div>
  </div>
</footer><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/katex.min.js" integrity="sha384-G0zcxDFp5LWZtDuRMnBkk3EphCK1lhEf4UEyEM693ka574TZGwo4IWwS6QLzM/2t" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
<script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha384-w5y/xIeYixWvfM+A1cEbmHPURnvyqmVg5eVENruEdDjcyRLUSNej7512JQGspFUr" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@3.4.1/dist/js/bootstrap.min.js" integrity="sha384-aJ21OjlMXNL5UyIl/XNwTMqvzeRMZH2w8c5cRVpzpU8Y5bApTppSuUkhZXN0VxHd" crossorigin="anonymous"></script>

<script src="http://localhost:1313/js/main.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe.min.js" integrity="sha384-QELNnmcmU8IR9ZAykt67vGr9/rZJdHbiWi64V88fCPaOohUlHCqUD/unNN0BXSqy" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/photoswipe/4.1.2/photoswipe-ui-default.min.js" integrity="sha384-m67o7SkQ1ALzKZIFh4CiTA8tmadaujiTa9Vu+nqPSwDOqHrDmxLezTdFln8077+q" crossorigin="anonymous"></script><script src="http://localhost:1313/js/load-photoswipe.js"></script>









<script src="http://localhost:1313/js/toc-enhancements.js"></script>


    
  </body>
</html>

